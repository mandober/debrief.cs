# Surrogate key

Surrogate key is a unique identifier for an entity/object in a db, that, unlike a *natural key*, is not derived from application data.

A surrogate key is also called *synthetic key*, *entity identifier*, *system-generated key*, *database sequence number*, *factless key*, *technical key*, *arbitrary unique identifier*.

Properties of surrogate keys:
- value is unique system-wide, never reused
- value is system generated
- value is not available for manipulation by clients (users, apps)
- value is not even visible to clients (users, apps)
- value contains no semantic meaning (factless)
- it is not derived from data
- value is not composed of several values from different domains
- its only purpose is to act as the primary key

Having the key independent of all other columns insulates the database relationships from changes in data values or database design (making the database more agile) and guarantees uniqueness. Some database designers use surrogate keys systematically regardless of the suitability of other candidate keys, while others will first see to use a key already present in the data.


Names for surrogate key data type in popular DBs:
- Sybase and SQL Server, identity column: `IDENTITY`, `IDENTITY(n,n)`
- Oracle: `SEQUENCE`, `GENERATED AS IDENTITY` (from v.12.1)
- SQL Server: `SEQUENCE` (from SQL Server 2012)
- PostgreSQL, IBM Informix: `serial`
- MySQL: `AUTO_INCREMENT`
- SQLite: `AUTOINCREMENT`
- Microsoft Access: `AutoNumber`
- IBM DB2: `AS IDENTITY GENERATED BY DEFAULT`
- Teradata: *Identity column* (implemented in DDL)
- *UUID* Universally Unique Identifier
- *GUID* Globally Unique Identifier
- *OID* Object Identifier
- *Table Sequence*, when the sequence is calculated by a procedure and a sequence table (with sequence table's columns: `id`, `sequenceName`, `sequenceValue` and `incrementValue`)

Advantages:
- Immutable during the row's lifetime, valid reference is always guaranteed
- Resistant to DB schema alterations
- Better performance: tied to a single column, have integer datatype
- Uniformity: table-independent coding
- Validation: distinctly looking keys for distinct tables/columns
- Compatibility



## Advantages of surrogate keys

### Immutability
Surrogate keys do not change while the row exists. This has advantage that apps cannot lose their reference to a db row, since the identifier never changes. The value of a primary or natural key can be modified, even with dbs that do not support cascading updates across related foreign keys.

### Requirement changes
Attributes that uniquely identify an entity might change, which might invalidate the suitability of natural keys. Some problem domains do not clearly identify a suitable natural key. Surrogate keys avoid choosing a natural key that might turn out unsuitable or non-future-proof (and future is unknown).

### Performance
Surrogate keys tend to be a compact number data type (e.g. integer, long). This allows the database to scan the single key column faster than it could multiple columns (had the primary key has been set as compound key). Also, a non-redundant distribution of keys causes the resulting underlying b-tree index to be completely balanced. Using the join family of SQL directives is less expensive with surrogates because there is only one column to process (vs several columns if using compound keys).

### Compatibility
When using several db application development systems, drivers or ORMs, it is much easier to use an integer or GUID surrogate (instead of a natural key) in order to support db-system-agnostic operations and object-to-row mapping.

### Uniformity
When every table has a uniform surrogate key, some tasks can be easily automated by writing code in a table-independent way.

### Validation
It is possible to design key/values that follow a well-known pattern or structure which can be automatically verified. For example, the keys intended for one column can look differently then the keys intended for another, thereby simplifying the detection of misplaced keys. However, this characteristic of the surrogate keys should never be used to drive any of the logic of the applications themselves as this would violate the *database normalization* principle.


## Disadvantages of surrogate keys

### Disassociation
The values of generated surrogate keys have no relationship to the real-world meaning of the data held in a row. When inspecting a row holding a foreign key reference to another table using a surrogate key, the meaning of the surrogate key's row cannot be discerned from the key itself. Every foreign key must be joined to see the related data item. This can also make auditing more difficult, as incorrect data is not obvious.

Surrogate keys are unnatural for data that is exported and shared. A particular difficulty is that tables from two otherwise identical schemas (for example, a test schema and a development schema) can hold records that are equivalent in a business sense, but have different keys. This can be mitigated by not exporting surrogate keys, except as transient data (most obviously, in executing applications that have a "live" connection to the database).

When surrogate keys supplant natural keys, then domain specific referential integrity will be compromised.

### Query optimization
Relational databases assume a unique index is applied to a table's primary key. The unique index serves two purposes: (i) to enforce entity integrity, since primary key data must be unique across rows and (ii) to quickly search for rows when queried. Since surrogate keys replace a table's identifying attributes—the natural key—and since the identifying attributes are likely to be those queried, then the query optimizer is forced to perform a full table scan when fulfilling likely queries. The remedy to the full table scan is to apply indexes on the identifying attributes, or sets of them. Where such sets are themselves a candidate key, the index can be a unique index.

These additional indexes, however, will take up disk space and slow down inserts and deletes.

### Normalization
Surrogate keys can result in duplicate values in any natural keys. It is part of the implementation to ensure that such duplicates should not be possible.

### Business process modeling
Because surrogate keys are unnatural, flaws can appear when modeling the business requirements. Business requirements, relying on the natural key, then need to be translated to the surrogate key. A strategy is to draw a clear distinction between the logical model (in which surrogate keys do not appear) and the physical implementation of that model, to ensure that the logical model is correct and reasonably well normalised, and to ensure that the physical model is a correct implementation of the logical model.

### Inadvertent disclosure
Proprietary information can be leaked if sequential key generators are used. By subtracting a previously generated sequential key from a recently generated sequential key, one could learn the number of rows inserted during that time period. This could expose, for example, the number of transactions or new accounts per period. There are a few ways to overcome this problem:
- Increase the sequential number by a random amount.
- Generate a random key such as a UUID

### Inadvertent assumptions
Sequentially generated surrogate keys can imply that events with a higher key value occurred after events with a lower value. This is not necessarily true, because such values do not guarantee time sequence as it is possible for inserts to fail and leave gaps which may be filled at a later time. If chronology is important then date and time must be separately recorded.
