# Address Translation

*Limited direct execution* (LDE): for the most part, programs run directly on the hardware; however, at certain key points in time (such as when a process issues a system call, or a timer interrupt occurs), the OS gets involved and makes sure things are going as expected. Thus, the OS, with hardware support, tries to get out of the way of running programs, thus delivering efficient virtualization. However, by interposing at those critical points in time, the OS ensures that it maintains control over the hardware. Efficiency and control together are two of the main goals of any modern OS.

The generic technique we will use, which you can consider an addition to our general approach of limited direct execution, is something that is referred to as hardware-based address translation, or just address translation for short.

With address translation, the hardware transforms each memory access (e.g., an instruction fetch, load, or store), changing the virtual address provided by the instruction to a physical address where the desired information is actually located. Thus, on each and every memory reference, an address translation is performed by the hardware to redirect application memory references to their actual locations in memory.

Of course, the hardware alone cannot virtualize memory, as it just provides the low-level mechanism for doing so efficiently. The OS must get
involved at key points to set up the hardware so that the correct translations take place; it must thus manage memory, keeping track of which
locations are free and which are in use, and judiciously intervening to
maintain control over how memory is used.

Once again the goal of all of this work is to create a beautiful illusion: that the program has its own private memory, where its own code
and data reside. Behind that virtual reality lies the ugly physical truth:
that many programs are actually sharing memory at the same time, as
the CPU (or CPUs) switches between running one program and the next.

*Interposition* is a generic and powerful technique that is often used to
great effect in computer systems. In virtualizing memory, the hardware
will interpose on each memory access, and translate each virtual address
issued by the process to a physical address where the desired information is actually stored. However, the general technique of interposition is
much more broadly applicable; indeed, almost any well-defined interface
can be interposed upon, to add new functionality or improve some other
aspect of the system. One of the usual benefits of such an approach is
transparency; the interposition often is done without changing the client
of the interface, thus requiring no changes to said client.

*Software-based relocation*: In the early days, before hardware support arose, some systems performed a crude form of relocation purely via software methods. The basic technique is referred to as static relocation, in which a piece of software known as the loader takes an executable that is about to be run and rewrites its addresses to the desired offset in physical memory. However, static relocation has numerous problems. First and most importantly, it does not provide protection, as processes can generate bad addresses and thus illegally access other process's or even OS memory; in general, hardware support is likely needed for true protection. Another negative is that once placed, it is difficult to later relocate an address space to another location.

## Dynamic relocation

Dynamic, or hardware-based, relocation was introduced in the first time-sharing machines of the late 1950's is a simple idea referred to as *base and bounds*; the technique is also referred to as *dynamic relocation*. 

Specifically, we'll need two hardware registers within each CPU: one is called the *base* register, and the other the *bounds* or, sometimes called a *limit* register. The base register is used to transform virtual addresses (generated by the program) into physical addresses. A bounds (or limit) register ensures that such addresses are within the confines of the address space.

This base-and-bounds pair is going to allow us to place the address space anywhere we'd like in physical memory, and do so while ensuring that the process can only access its own address space.

In this setup, each program is written and compiled as if it is loaded at address zero. However, when a program starts running, the OS decides where in physical memory it should be loaded and sets the base register to that value.

When any memory reference is generated by the process, it is translated by the CPU in the following manner:

    physical_address = virtual_address + base

Each memory reference generated by the process is a *virtual address*; the hardware in turn adds the contents of the base register to this address and the result is a *physical address* that can be issued to the memory system.

Transforming a virtual address into a physical address is exactly the technique we refer to as address translation; that is, the hardware takes a virtual address the process thinks it is referencing and transforms it into a physical address which is where the data actually resides. Because this relocation of the address happens at runtime, and because we can move address spaces even after the process has started running, the technique is often referred to as *dynamic relocation*.
