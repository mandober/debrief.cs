# I Judgments and Rules

## 1. Abstract Syntax

Programming languages express computations in a form comprehensible to both people and machines. The syntax of a PL specifies how various sorts of language phrases (expressions, commands, declarations, etc.) may be combined to form programs.

A **concrete (surface) syntax** is concerned with how phrases are entered and displayed on a computer. The surface syntax is usually thought of as given by strings of characters from some alphabet (Unicode).

The **abstract (structural) syntax** is concerned with the structure of phrases, specifically how they are composed from other phrases. At this level, a phrase is a tree, called an *Abstract Syntax Tree (AST)*, whose nodes are operators that combine several phrases to form another phrase.

The *binding structure of syntax* is concerned with the introduction and use of identifiers: how they are declared, and how declared identifiers can be used. At this level, phrases are *Abstract Binding Trees (ABT)*, which enrich AST with the concepts of binding and scope.

A *pieces of syntax* will be a finite tree augmented with a means of expressing the binding and scope of identifiers within a syntax tree. We define a "piece of syntax" in two stages:
1. AST captures the hierarchical structure of a piece of syntax 
  (avoiding the commitment of a concrete representation)
2. Abstract Binding Trees (ABT) is enhanced AST with the means of specifying 
  the binding (declaration) and scope (range of significance) of an identifier

### 1.1 Abstract Syntax Tree

AST is an *ordered tree* whose leaves are *variables*, and whose interior nodes are *operators* whose arguments are its children. ASTs are classified into a variety of sorts corresponding to different forms of syntax.

ASTs can be combined by an operator, which has an *arity* specifying the sort of the operator and the number and sorts of its arguments. An operator of sort `s` and arity `s₁, …, sₙ` (`n ≥ 0`) combines ASTs of sort `s₁, …, sₙ`, respectively, into a compound AST of sort `s`.

A *variable* stands for an unspecified, or generic, piece of syntax of a specified sort. A variable is an unknown object drawn from some domain. The unknown can become known by *substitution* of a particular object for all occurrences of a variable in a formula, thereby *specializing* a general formula to a particular *instance*.

> A variable is a place-holder, an unknown whose meaning is given by substitution.

For example, in algebra variables range over real numbers, and we may form polynomials, such as `x² + 2x + 1`, that can be specialized by substitution of `x = 7` to obtain `7² + 2 × 7 + 1`, which can be simplified according to the laws of arithmetic to `64`, which is `(7 + 1)²`.

Abstract syntax trees are classified by sorts that divide ASTs into *syntactic categories*. For example, PL often have a syntactic distinction between expressions and commands; these are two sorts of ASTs. Variables in ASTs range over sorts in the sense that only ASTs of the specified sort of the variable can be plugged in for that variable. Thus, it would make no sense to replace an expression variable by a command, nor a command variable by an expression, the two being different sorts of things.

For example, a language of arithmetic expressions built from numbers, addition, and multiplication is single-sorted; its abstract syntax consists of a single sort `Exp` generated by the operators:
1. operator `num[n]` of sort `Exp` for each `n ∈ N`
2. operators `plus` and `times` of sort `Exp`, each with 2 args of sort `Exp`

```hs
data Exp where
  EInt :: Exp
  Plus :: Exp -> Exp -> Exp
  Mult :: Exp -> Exp -> Exp
```

The expression `2 + (3 × x)`, which involves a variable `x`, would be represented by the ast `plus(num[2], times(num[3], x))` of sort `Exp`, under the assumption that `x` is also of this sort.

```
  +
 / \
2   ×
   / \
  3 × x
```

The AST's tree structure provides a very useful principle of reasoning, called *structural induction*. Suppose that we wish to prove that a property `P(a)` holds for all ASTs `E` of a given sort. To show this, it is enough to consider all ways in which `E` can be generated, and show that the property holds in each case under the assumption that it holds for its constituent ASTs (if any).

In the case of the sort `Exp` just described, we must show:
1. The property holds for any variable `x` of sort `Exp`: 
  prove that `P(x)`
2. The property holds for any number, `num[n]`: 
  for every `n ∈ N`, prove that `P(num[n])`
3. Assuming that the property holds for `E₁` and `E₂`, 
  prove that it holds for `plus(E₁,E₂)` and `times(E₁,E₂)`: 
  if `P(E₁)` and `P(E₂)`, then `P(plus(E₁,E₂))` and `P(times(E₁,E₂))`.

Because these cases exhaust all possibilities for the formation of `E`, we are assured that `P(E)` holds for any ast a of sort `Exp`.


### 1.2 Abstract Binding Trees

An abstract binding tree (ABT) enriches an AST with the means to introduce new variables and symbols, called bindings, with a specified scope.

The crucial principle is that any use of an identifier should be understood as a reference, or abstract pointer, to its binding.
