# Compiler theory :: Parsing :: Lexical analysis

https://en.wikipedia.org/wiki/Lexical_analysis

**Lexical tokenization** is conversion of a text into semantically or syntactically meaningful *lexical tokens* belonging to categories defined by a *lexical grammar*.

In case of a natural language, those categories include nouns, verbs, adjectives, punctuations etc.

In case of a programming language, the categories include
- identifiers
- operators
- grouping symbols
- data types

## Rule-based programs

A rule-based program, performing lexical tokenization, is called **tokenizer** or **scanner**, although scanner is also a term for the first stage of a lexer.

A lexer forms the first phase of a compiler frontend in processing. 
Analysis generally occurs in one pass. 

*Lexers* and *parsers* are most often used for compilers, but can be used for other computer language tools, such as pretty-printers or linters. 

Lexing can be divided into two stages:
- **scanning stage** segments the input stream into syntactic units called *lexemes* and categorizes these into *token classes*
- **evaluating stage** converts lexemes into *processed values*

Lexers are generally quite simple, with most of the complexity deferred to the *syntactic analysis* or *semantic analysis* phases, and can often be generated by a *lexer generator*, notably 'lex' or its derivatives.

However, lexers can sometimes include some complexity, such as *phrase structure processing* to make input easier and simplify the parser, and may be written partly or fully by hand, either to support more features or for performance.

A **lexical token** is a string with an assigned, and thus identified, meaning. A lexical token consists of a token name and an optional token value. The token name is a category of a rule-based lexical unit. 

Examples of common tokens

token name | desc                                         | Sample token value
-----------|----------------------------------------------|---------------------
identifier | Names assigned by programmer                 | x, color, UP
keyword    | Reserved words of language                   | if, while, return
delimiters | Punctuation chars and paired delimiters      | `}`, `(`, `;`
operator   | Symbols operating on args, producing results | +, <, =
literal    | Numeric, logical, textual, ref literals      | true, 6.2e23, "om"
comment    | Line or block comment, usually discarded     | // later
whitespace | Groups of non-printable characters           | SPACE, TAB, VTAB, LF

- token name is a lexical category
- sep/punct = separators, punctuation chars, paired delimiters

An **identifier** is a *lexical token* that names variables and other language entities like functions, data types, modules.

A **reserved word** (or a reserved identifier) is a *word*, conforming to the naming rules of language identifiers, which cannot be used as an identifier, such as the name of a variable or function. A language reserves a set of words that are treated specially by the compiler. For example, many PLs have the conditional construct if-then-else which has short-cicuiting semantics; even though the user may define a function that emulates it, the short-cicuiting semantics cannot be replicated (at all or not easily).

A **delimiter** is a sequence of one or more characters for specifying the boundary between separate, independent regions in streams. For example, the comma character is often used to delimit fields (of a list); space is probably the most used delimiter character. In general, delimiters are not only character-based; e.g. Morse code transmission uses time as a separator. The ASCII standard has long ago reserved 4 control characters for this purpose:
-  field separator FS 0x1C
-  group separator GS 0x1D
- record separator RS 0x1E
-   unit separator US 0x1F
