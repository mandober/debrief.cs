# PLT :: TERMS

bottom type
unit type
singleton type
top type
universal type
subtyping
subtype
supertype
covariance
contravariance
invariance
nonvariance
algebraic data type
type constructor
type erasure
compile-time transformation
defunctionalization
flow control
branching
condition
conditional branching
conditional execution
Abstract data type
Abstract interpretation
Abstract machine
Abstract syntax
Academic programming language
Agent-based programming language
Agent-oriented programming language
Algebraic modeling language
Algebraic semantic
APL implementer
Applicative computing system
Axiomatic semantic
Comparative programming language analysis
Compiler construction
Compiler optimization
Compiler structure
Compiler theory
Concatenative programming language
Concurrent programming language
Constraint programming language
Container
Control-flow analysis
Convergence
Criticisms of programming language
Data Type
Data-flow analysis
Data-structured programming language
Declarative programming language
Denotational semantics
Dependently typed language
Dependently typed programming
Discontinued programming language
Divergence
Domain theory
Domain-specific languages (DSL)
Dynamic programming languages
Dynamically-typed programming languages
Educational abstract machine
Efferent coupling
Esoteric programming languages
Experimental programming languages
Extensible syntax programming languages
First-class function
Fluent
Formal language
Formal Semantics types
Formula manipulation languages
Function-level languages
Function-level programming
Functional languages
Grammars
Graph rewriting
Graph rewriting
High Integrity Programming Language
High-level programming languages
Higher-order abstract syntax
Hoare logic
Implementation
Implementation of functional programming languages
Incremental computing
Jump threading
Lambda calculus
Latent typing
Lists of programming languages
Logic error
Logic of Computable Functions
Low-level programming languages
Misc
Multi-paradigm programming languages
Non-English-based programming languages
Non-local variable
Nondeterministic programming languages
Object-based programming languages
Operational semantics
Operational semantics
Orthogonality
Pattern matching programming languages
PL Analysis
PL Characterization
PL Classification
PL Design
PL Implementation
Polymorphism
POPLmark challenge
Principal type
Procedural programming languages
Process termination functions
Program analysis
Program analysis 
Program logic
Program transformation
Program transformation
Program transformation tools
Programming Computable Functions
Programming Language
Programming Language classification
Programming language families
Programming language semantics
Programming language standards
Programming language syntax
Programming language theory
Programming languages
Programming languages by creation date
Programming languages conferences
Programming languages created by women
Programming languages with an ISO standard
Proof assistants
Proof-carrying code
Prototype-based programming languages
Qualification principle
Reactive programming languages
Referential transparency
Refinement type
Reflexive closure
Rewriting systems
Run-time systems
Secure programming languages
Semantic error
Semantics
Set theoretic programming languages
Shading languages
Side effect
Software by programming language
Software metrics
Source-to-source compilers
Static program analysis
Static program analysis tools
Statically typed programming languages
Stream
Structured program theorem
Subject reduction
Substitution
Substitution
Substitution
Synchronous programming languages
Syntactic closure
Syntax
Syntax error
System F-sub
Term-rewriting programming languages
Term-rewriting programming languages
Text-oriented programming languages
Tree programming languages
Turing completeness
Turing machine
Type inference
Type inhabitation
Type rule
Type systems
Type theory
Type variable
Typed assembly language
Typing environment
Unification
Value restriction
Variadic
Visual programming languages
XML-based programming languages

ownership
mutability
lifetime
constants
side-effects
flow control
reflexion
scope
declaration
definition
initialization
polymorphism
method extensions
constructors
destructors
magic methods
static methods

abstract data type
abstract function
abstract interpretation
abstract syntax
abstraction

academic programming language
access level
accessing object member
accessing static member
activation record
active block
ad hoc generic
ad hoc polymorphic domain
ad hoc polymorphism
agent-based programming language
agent-oriented programming language
algebraic modeling language
algorithm
alias
aliasing
alignment, word alignment
allocation
allocation process
anonymous method
application
applicative computing system
arity
array
array access
array allocation
array assignment
array bound
array declaration
array dimension
ASCII
assembly
assertion
asynchronous method
asynchronous return type
atomic (language element)
attribute
authoring-time
auto-implemented property
automatic conversion
axiom
backtracking
backtracking algorithm
base type of a pointer
base type of a set
base type of an array
BCD (binary coded decimal)
beta redex
beta reducible expression
beta reduction
binary coded decimal
binary operator
binary operator overloading
binding
binding
binding time
bitwise operator
block exit time
block structure
BNF
bool
bool type
Boolean
bound variable
boxing/unboxing
business logic
call-by-address
call-by-constant
call-by-name
call-by-name order
call-by-need
call-by-pointer
call-by-return
call-by-value-and-return
call-with-current-continuation, call/cc
call/cc, call-with-current-continuation
caller
caller information
calling generic method
calling method
capture-avoiding substitution
captured reference
captured variable
catch block
char
char type
checkpoint
class
class
class interface
class member
clausal logic
coherent assignment
collection
combinatorial explosion
comment
comparative programming language analysis
compile-time
compile-time binding
compiler bug
compiler construction
compiler optimization
compiler optimization
compiler structure
compiler theory
complete
complete name
complete system
comprehension
computation tree
computer representation
concatenative programming language
concept
conclusion
concrete type
concurrent programming language
conditional
conditional expression
conditional sentence
conditional statement
conformant array
conservative conversion
constant
constant field
constant guideline
constraint
constraint programming language
constructor chaining
constructor overloading
container (type theory)
contents of an object
context free language
continuation
control diagram
control structure
control-flow analysis
convergence (logic)
counted loop
criticisms of programming language
curry a function
currying
custom async method
custom conversion
cut operation, for resolution
cut, prolog
dangling reference
data hiding
data-flow analysis
data-structured programming language
deallocation
death of an object
death of name
death of object
decidable
declaration
declarative programming language
deduction
default
default constructor
default value
default value
defining method
defining occurrence
definition
delegate
delegate signature
delegates as parameter
demotion
demotion cast
denotation
dependently typed programming
dereference
derived type
destructive assignment
destructor
dictionary
diffuse representation
discontinued programming language
dispatch
dispatch a call
distinguishable domain
divergence (computer science)
domain
domain checking
domain mapping
domain theory
domain-specific language
domain-specific programming language
downcast
dsl
dual type
dyadic operator
dynamic parent
dynamic programming language
dynamic scope
dynamic scoping
dynamic storage
dynamically typed programming language
ebcdic
EBNF
educational abstract machine
efferent coupling
encapsulate
enum
enum access level
enum constant type
enum constant value
enum example
enum method
enum scope
enumerated type
environment
error propagation
escape character
esoteric programming language
evaluation, inside-out
evaluation, outside-in
event
event caller
event handler
event keyword
exception
exception filter
exception handler
exception handling
expansion of a non-terminal
experimental programming language
explicit conversion methods
explicit representation
expression body member
expression trees
expressive language
extended return type
extensible syntax programming language
extension
extension 107606 index
extension method
extent of an object
external domain
external object
external scope
finally block
first class object
first class object
first-class function
first-order predicate calculu
fixed point number
floating-point type
fluent (artificial intelligence)
formal semantics type
formula manipulation language
free union
free variable
free variable
freelist
front end processor
function application
function call
function domain
function invokaction
function method
function range
function-level language
function-level programming
functional
functional composition
functional language
functionality interface
functor
garbage collection
general loop
generate a program
generator
generic class
generic class inheritance
generic delegate
generic event
generic interface
generic method
generic object
generic package
generic type
generic type parameter
generics
generics
generics and object
global scope
goal
good restriction
grammar
guarded expression
heap allocation
heap storage
hidden data
hiding member
high integrity programming language
high-level programming language
higher-order abstract syntax
hoare logic
horn clause
hyperresolution
identifier
immortal object
implementation
implementation
implementation of functional programming language
implementer
implicit conversion method
implicit representation
in parameter
in-line code
incremental computing
independent domain
indeterminate result
index type
indexer
indexer overloading
indexer parameter
indirectly bound
infinite list
information-losing conversion
inherit
inherited
inherited function
initial field value
initialization
inner class
inner scope
instance of a generic domain
instantiate a package
instantiate, in c++
instantiated type
instantiation
integral type
interface
interface example
interface signature
internal access
internal domain
internally merged domain
invisible name
irov
iteration element
iterator
jagged array
jump threading
keyword
keyword
labeled scope
lambda calculus
lambda calculus formulas 97index
lambda calculus variable
lambda evaluation
lambda expression
lambda expression
lambda expression body
lambda expression parameter
lambda function call syntax
lambda reduction rule
lambda substitution
language extension
latent typing
lex
lexer
lexer generator
lexical analysis
lexical ancestor
lexical delimiter
lexical parent
lexical scoping
lexical token
lifetime of object
lifted/unlifted
lisp atom
lisp lambda expression
list
list comprehension
list specification
lists of programming language
local constants
local methods
local scope
logic error
logic language
logic of computable function
logical consequence
logical operator
loop
loop variable
low-level programming language
makefile
masked definition
meaning of a name
meaning of a program
meaning of an object
meaning of code
meaning of expression
memory allocation
memory fragmentation
memory management
message
metalanguage
method
method overloading
method parameter
mode
mode graph
modularity
module
monadic operator
multi-paradigm programming language
multicast delegate
multiple assignment
multiple constraint
multiply bound name
n-ary
n-step proof
name (identifier)
name binding
name conflict
name refers to
named argument
namespace
namespace access
naming conflict
necessary control structure
nested lifetime
nested namespace
nested scope
non-english-based programming language
non-local variable
nondeterministic programming language
nonstandardized language
normal exit
normal function call-syntax
normal order
nuance
null keyword
null-coalescing operator
null-conditional operator
nullable type
object
object
object class
object creation
object initializer
object-based programming language
one-based subscripting
one-in/one-out
opaque derived mode
open list
operand
operator
operator
operator overloading
operator overloading
operator overloading example
optional parameter
orthogonality (term rewriting)
out keyword
outer scope
overloadable operator
overloaded name
overloading
p-code
parallel array
parallel evaluation
parallel language
parameter mode
parameterized domain
parameterized generic domain
parameterized module 531608 index
parameterized type expression
parametric polymorphism
params keyword
parser
parser generator
partial class
partial parameterization
pass by reference
pass by value
pattern matching
pattern matching programming languages
pointer aliasing
pointer assignment
pointer variable
polymorphic object
polymorphism
polymorphism (computer science)
poplmark challenge
portable code
portable program
postfix order
powerful language
predicate
prefix order
prefix syntax
premise
preprocessor
priming read
primitive
primitive control
principal type
private access
private protected access
private symbol
procedural language
procedural programming language
process
process termination function
program logic
program object
program transformation tool
programming
programming computable function
programming language
programming language analysis
programming language characterization
programming language design
programming language family
programming language implementation
programming language semantics
programming language standard
programming language syntax
programming languages by creation date
programming languages conference
programming languages created by women
programming languages with an iso standard
promises
promotion
promotion cast
proof
proof assistant
proof system
proof-carrying code
property
property
property access level
property advantage
proposition
protected access
protected internal access
prototype-based programming language
public access
public symbol
publisher
pure functional language
pure value
qualification principle
qualifier list
raising event
rank of an array
reactive programming language
read-only and write-only property
readonly
rectangular array
recurrence equation
redefining member
redex
redex
reduction
ref keyword
reference
reference
reference constructor
reference conversion
referential transparency
refinement type
reflection
reflexive closure
refutation
relatively global scope
representation of an object
represented by
resolution deduction
resolution proof
restriction, constraint
return statement
return types and parameter
rewriting system
rule, prolog
run-time
run-time binding
run-time dispatcher
run-time stack
run-time system
satisfy
scientific computer
scope
scope
scope of a name
scope of quantifier
scope-resolution operator
script
sealed keyword
secure programming language
selection function
semantic ambiguity
semantic error
semantic rule
semantic validity
semantics
semiindependent domain
sentence
serialization
set theoretic programming language
shading language
short circuit evaluation
side effect (computer science)
simple object
simple type
size
slice of an array
software by programming language
software metric
source
source-time
source-time binding
source-to-source compiler
spaghetti code
species of a generic domain
specific domain
specific type
specification
specification 338index
stack frame
static
static class
static constructor
static field
static method
static program analysis
static program analysis tool
static storage
statically typed programming language
storage compaction
storage object
string
string comparison
string concatenation
string member
stringbuilder class
struct
struct constructor
struct field initializer
struct guideline
struct inheritance
struct variable
structure of a program
structured editor
structured program theorem
structured programming
subdomain
subject reduction
subroutine call
subroutine return
subscriber
subscribing to event
subscripting
substitution
superdomain
symbol table
synchronous programming language
syntactic analysis
syntactic category
syntactic closure
syntactic sugar
syntax error
system f-sub
tail recursion
term
terminated string
text-oriented programming language
the async and await keyword
the is and as keyword
the using statement
theorem
theory
this keyword
throwing exception
top-level access level
tree programming language
tripcount
true and false operator overloading
try-catch statement
tuple
turing completeness
turing machine
type
type checking
type compatible
type constructor
type declaration
type description
type error
type inference
type inhabitation
type match
type name
type of a type
type rule
type system
type tag
type theory
type variable
type-object
typed assembly language
typing environment
unary operator
unary operator overloading
unbound name
unbound symbol
unboxing
undefined name
unification
union type
unit record equipment
universe of discourse
unlabeled scope
until test
upcast
upward compatibility
use of an identifier
use of parameter
using directive
valid representation
valid sentence
value and reference type
value constructor
value of an object
value restriction
var parameter passing
variable
variable declaration
variable scope
variable type
variadic
variance
virtual class
virtual function
visibility
visible name
visual programming language
while test
xml-based programming language
zero-based subscripting
ZF expression

* name
  identifier
  label
  named function
  overloading
  undefined name
  namespace
  namespace path
  namespace extent
  nested namespaces

* null
  null keyword
  null-coalescing operator
  null-conditional operator
  nullable types

* object
  object class
  object creation
  object initializer
  object instantiation

* operator
  unary operator
  binary operator
  ternary operator
  overloadable operator
  overloaded operator

* parameter
  formal parameter
  actual parameter
  optional parameter

* value
  data
  object
  boxing
  unboxing
  reference value

* variable
  immutable variable

* code block
  statement
  expression
  expression statement

* scope
  extent
  lifetime
  bound variable
  free variable
  binder
  binding context

* calling convention
  call-by-address
  call-by-constant
  call-by-name order
  call-by-name
  call-by-need
  call-by-pointer
  call-by-return
  call-by-value-and-return
  call/cc
  call-with-current-continuation

* functions
  functions: first class functions
  functions: can be passed
  functions: can be returned
  functions: anonymous
  functions: lambdas
  functions: prototypes
  closures

* inheritance
  direct
  multple
  prototypical


access level
accessing object member
accessing static member
anonymous method
array access
array allocation
array assignment
array declaration
arrays
assemblies
assignment
async return types
asynchronous methods
attributes
auto-implemented properties
base keyword
bool type
caller information
calling generic methods
calling methods
catch block
char type
class
class interface
classes
collections
comments
concepts
conditionals
constant fields
constant guideline
constants
constraints
constructor
constructor chaining
constructor overloading
custom async methods
custom conversions
declaration
default constructor
default values
definition
defining methods
delegate signature
delegates
delegates as parameters
destructor
downcast
enum
enum constant type
enum access levels
enum scope
enum constant values
enum example
enum methods
escape characters
event caller
event handler
event keyword
events
exception filters
exception handling
explicit conversion methods
expression body members
expression trees
extended return types
extension methods
finally block
floating-point types
functionality interface
garbage collector
generic class inheritance
generic classes
generic delegates
generic events
generic interfaces
generic methods
generic type parameters
default value
generics
generics and object
overriding members
hiding members
implicit conversion methods
in parameters
indexer overloading
indexer parameters
indexers
inheritance
initial field values
inner classes
integral types
interface example
interface signatures
interfaces
internal access
iterators
jagged arrays
keywords
lambda expressions
local constants
local methods
loops
method overloading
method parameters
methods
multicast delegates
multiple constraints
instantiation
out keyword
overriding members
params keyword
partial class
pass by reference
pass by value
pattern matching
preprocessor
private access
private protected access
properties
property access levels
property advantages
protected access
protected internal access
public access
publisher
raising events
read-only and write-only properties
readonly
rectangular arrays
redefining members
ref keyword
reflection
return statement
return types and parameters
sealed keyword
serialization
simple types
static
static classes
static constructor
static fields
static methods
string comparison
string concatenation
string members
stringbuilder class
strings
struct
struct constructors
struct field initializers
struct guideline
struct inheritance
struct variable
subscriber
subscribing to events
syntax
the async and await keywords
the is and as keywords
the using statement
this keyword
throwing exceptions
top-level access levels
true and false operator overloading
try-catch statement
unary operator overloading
unboxing
upcast
using directive
value and reference types
variable scope
variable type
variables
variance
constraints
abortive exit
abstract data type
abstract function
abstraction
abstraction
activation record
active block
ad hoc generic
ad hoc polymorphic domain
ada derived type
ada generic
additional binding
adt
alias
allocation process
ambiguity
application
arity
array bounds
array dimension
ascii
assertion, prolog
assignment
atom, prolog
automatic conversion
axioms
backtrack, prolog
bad restriction
base type of a pointer
base type of a set
base type of an array
bcd
beta redex
beta reducible expression
binary operator
binding a name
binding at source time
binding time
birth of name
block
birth of object
bitwise operators

BNF

  bound variable
captured reference
checkpoint
class member
clausal logic
closure
closure
coherent assignment
coherent representation
604index
coherent representation
combinatorial explosion
compiler bug
complete name
complete system
complete
comprehension
computation tree
computer representation
conclusion
concrete type
conditional expression
conditional sentence
conditional statement
conformant arrays
conservative conversion
constructor
contents of an object
context free languages
continuation
control diagram
control frame
control frame
control structure
counted loop
curry a function
currying
cut operation, for resolution
cut, prolog
dangling reference
data hiding
data type
deallocation
death of an object
death of name
death of object
decidable
declaration
deduction
defaults
defining occurrence
demotion cast
demotion
denotational semantics
denotes
dereference
destructive assignment
dictionary
diffuse representation
dispatch a call
dispatch
dispatcher
dispatcher
distinguishable domains
domain checking
domain mapping
domain
dual type
dyadic operator
dynamic binding
dynamic binding
dynamic link
dynamic link
dynamic parent
dynamic scope
dynamic scoping
dynamic storage
ebcdic
encapsulate
encoding conversion
encoding conversion
enumerated type
environment
error propagation
evaluation, inside-out
evaluation, outside-in
exception handler
exception
expansion of a non-terminal
explicit representation
expressive language
extension 107606 index
extension
extent of an object
external domain
external object
external scope
first class object
first class objects
first-order predicate calculus
fixed point number
fixed point
fixed point
* flexi
  data
  object
  flexible language
  object flexible
  reference value language


freel* ist
free   variableon
free   variable
front end processor
function domain
function method
function range
functional composition
functional language
functional language
functional
functor
garbage collection
garbage collector
garbage
garbage
general loop
generate a program
generator
generic domain
generic domain
generic function
generic function
generic object
generic package
generic package
generic packages
global scope
goal
good restriction
guarded expression
heap allocation
heap storage
hidden data
higher-order function
higher-order function
horn clause
hyperresolution
identifier
immortal object
implicit representation
independent domains
indeterminate result
index type
indirectly bound
infinite list
information-losing conversion
inherit
inheritance
inheritance
inherited function
inherited
initialization
in-line code
instance of a generic domain
instantiate a package
instantiate, in c++
instantiate
instantiate
instantiated type
instantiation
internal domain
internally merged domains
invisible name
object iteration
reference value scope

lambda evaluation
lambda calculus   variablemulas 97index
lambda calculus   variable
lambda expression body
lambda expression parameter
lambda expression
lambda function call syntax
lambda reduction rule
lambda substitution
language extension
lazy evaluation
lazy evaluation
lex
lexer generator
lexer
lexical analysis
lexical ancestor
lexical delimiter
lexical parent
lexical scoping
lexical token
lifetime of object
lisp atom
lisp lambda expression
list comprehension
list specification
list
local scope
* logic
  data
  object
  logic language
  object logical
  reference valuemakef* ile

  loopical operators
  loop variable

masked definition
meaning of a name
meaning of a program
meaning of an object
meaning of code
meaning of expression
memory fragmentation
memory management
message
metalanguage
method
method
mode graph
mode
modularity
module
monadic operator
multiple assignment
multiply bound name
name binding
name conflict
name refers to
naming conflict
n-ary
necessary control structures
nested lifetimes
nonstandardized language
normal exit
normal form
normal form
normal form
normal function call-syntax
normal order
n-step proof
nuance
object
object-oriented language
object-oriented language
one-in/one-out
opaque derived mode
open list
operands
overloaded name
parallel arrays
parallel evaluation
parallel language
parameter mode
parameterized generic domain
parameterized domain
parameterized module 531608 index
parameterized type expression
parse tree
parse tree
parse tree
parser generator
parser
 data
  object
  parser
  object partial
  reference value


polymorphic object
pointer variable alignment
pointer variable
polymorphic type
portable code
portable program
postfix order
powerful language
predicate
prefix order
prefix syntax
premise
priming read
primitive control
primitive
private symbol
procedural language
process
program object
promises
promotion cast
promotion
proof system
proof
proposition
public symbol
pure functional language
pure value
qualifier list
rank of an array
recurrence equation
redex
reduction
reference constructor
reference conversion
reference
refutation
relatively global scope
representation of an object
represented by
resolution deduction
resolution proof
resolution
resolution
rule, prolog
run-time dispatcher
run-time stack
satisfy
scientific computer
scope of a name
scope of quantifier
scope
scope-resolution operator
selection function
semantic basis
semantic basis
semantic intent
semantic intent
semantic rules
semantic validity
semiindependent domains
sentence
short circuit evaluation
simple object
size conversion
size conversion
size
slice of an array
spaghetti code
species of a generic domain
specific domain
specific type
specification 338index
stack frame
static binding
static binding
static link
static link
static storage
storage compaction
storage object
stream
strict evaluation
strict evaluation
strict evaluation
strongly typed language
strongly typed language
structure of a program
structured editor
structured programming
subdomain
subroutine call
subroutine return
superdomain
symbol table
syntactic analysis
syntactic category
syntactic sugar
syntax
tail recursion
term
terminated string
theorem
theory
tripcount
tuple
type cast
type cast
type checking
type coercion
type coercion
type compatible
type constructor
type conversion
type conversion
type declaration
type description
type error
type match
type name
type of a type
type predicate
type predicate
type tag
type
type-object
unary operator
unbound name
unbound symbol
unification
union types
unit record equipment
universe of discourse
unlabeled scope
until test
upward compatibility
use of an identifier
use of parameter
valid representation
representation
valid sentence

* value
  data
  object
  value constructor
  object value
  reference value
  l-value
  r-value
  undefined value

* variable
  variable parameter passing
  variable declaration

virtual class
virtual function
visibility
visible name
while test
word alignment
zero-based subscripting
zf expression
programming
programming language
programming language theory
formal language
data type
syntax
grammar
semantics
formal semantics type
denotational semantics
operational semantics
axiomatic semantics
hoare logic
algebraic semantics
compiler theory
compiler construction
compiler optimization
compiler structures
program analysis
control-flow analysis
data-flow analysis
incremental computing
software metric
static program analysis
abstract interpretation
static program analysis tools
program transformation
comparative programming language analysis
program analysis
program transformation
compiler optimizations
program transformation tool
source-to-source compiler
run-time system
programming language classification
domain-specific languages
dsl
programming language
programming language design
programming language implementation
programming language analysis
programming language characterization
programming language classification
implementation
abstract machines
educational abstract machines
turing machine
apl implementers
graph rewriting
implementation of functional programming languages
dependently typed programming
dependently typed languages
proof assistants
lambda calculus
abstract machines
applicative computing systems
substitution
programming languages
programming language families
software by programming language
programming languages conferences
programming languages by creation date
programming languages created by women
lists of programming languages
academic programming languages
agent-based programming languages
agent-oriented programming languages
algebraic modeling languages
concatenative programming languages
concurrent programming languages
constraint programming languages
criticisms of programming languages
data-structured programming languages
declarative programming languages
dependently typed languages
discontinued programming languages
domain-specific programming languages
dynamic programming languages
dynamically typed programming languages
esoteric programming languages
experimental programming languages
extensible syntax programming languages
formula manipulation languages
function-level languages
functional languages
high integrity programming language
high-level programming languages
programming languages with an iso standard
low-level programming languages
multi-paradigm programming languages
non-english-based programming languages
nondeterministic programming languages
object-based programming languages
pattern matching programming languages
procedural programming languages
process termination functions
programming language syntax
prototype-based programming languages
reactive programming languages
secure programming languages
set theoretic programming languages
shading languages
programming language standards
statically typed programming languages
synchronous programming languages
term-rewriting programming languages
text-oriented programming languages
tree programming languages
visual programming languages
xml-based programming languages
wikipedia categories named after programming languages
rewriting systems
abstract machines
graph rewriting
substitution (logic)
term-rewriting programming languages
unification (computer science)
programming language semantics
axiomatic semantics
program logic
denotational semantics
domain theory
operational semantics
abstract machines
substitution (logic)
type theory
abstract data types
polymorphism (computer science)
type inference
type systems
programming language theory
abstract syntax
divergence (computer science)
first-class function
function-level programming
higher-order abstract syntax
logic error
logic of computable functions
non-local variable
poplmark challenge
programming computable functions
proof-carrying code
qualification principle
referential transparency
semantic error
side effect (computer science)
structured program theorem
syntax error
turing completeness
typed assembly language
variadic
specification
algebraic semantics
container (type theory)
convergence (logic)
efferent coupling
fluent (artificial intelligence)
jump threading
latent typing
orthogonality (term rewriting)
principal type
refinement type
reflexive closure
stream
subject reduction
syntactic closure
system f-sub
type inhabitation
type rule
type variable
typing environment
value restriction

- scripting
- systems programming
- web dev
- markup
- DLS
- General purpose
- orientation
- side-effects
- mutability
- reflexion
- functional
- object-oriented
- aspect-oriented
Type System
Type checking (strictness)
- Statically typed
- Dynamically typed
untyped
commenting
documentation comment
information about the current line and file
tokens
breaking lines (useful when end-of-line and/or indentation has a special meaning)
variable assignment or declaration
grouping expressions
block (grouping statements, especially when statements are not expressions)
use a block as a return value (when statements are not expressions)
equality / inequality
comparison
runtime evaluation
manual memory allocation
force garbage collection
Functions
function call
partial application (in the examples below, a normal call is "f(a,b)")
function definition
anonymous function
function return value
function called when a function is not defined (in dynamic languages)
runtime inspecting the caller information
function composition
identity function
Control Flow
sequence
if_then
if_then_else
ifnot_then (unless)
multiple selection (switch)
loop
breaking control flow
exception
call-with-current-continuation
Types
declaration
annotation (or variable declaration)
cast
mutability, constness
Object Oriented & Reflexivity
method invocation
object creation
object cloning
manually call an object's destructor
class declaration
testing class membership
get the type/class corresponding to an object/instance/value
methods available
inheritance
has the method
current instance
accessing parent method
accessing child method
Package, Module
package scope
declare
import
Strings
type name
character type name
character "z"
strings
multi-line
convert something to a string (see also string interpolation)
serialize (marshalling)
unserialize (un-marshalling)
sprintf-like
simple print
string equality & inequality
string size
string concatenation
duplicate n times
upper / lower case character
uppercase / lowercase / capitalized string
ascii to character
character to ascii
accessing n-th character
extract a substring
locate a substring
locate a substring (starting at the end)
Booleans
type name
false value
true value
logical not
logical or / and
Bags and Lists
type name
list concatenation
list flattening
list constructor
list/array indexing
adding an element at the beginning (list cons)
adding an element at index
adding an element at the end
first element
all but the first element
last element
all but the last element
get the first element and remove it
get the last element and remove it
for each element do something
transform a list (or bag) in another one
transform two lists in parallel
find an element
keep elements
partition a list: elements matching, elements non matching
split a list
is an element in the list
is the predicate true for an element
is the predicate true for every element
smallest / biggest element
join a list of strings in a string using a glue string
list size
iterate with index
remove duplicates
sort
reverse
list of couples from 2 lists
2 lists from a list of couples
lookup an element in a association list
list out of a bag
f(... f(f(init, e1), e2) ..., en)
f(e1, f(e2, ... f(en, init) ...))
Various Data Types
tuple type
tuple constructor
computable tuple (these are a kind of immutable lists playing a special role in parameter passing)
reference (pointer)
optional value
record
union type declaration
enumerated type declaration
dictionary
range
Mathematics
type name
numbers syntax
addition / subtraction / multiplication / division
exponentiation (power)
negation
random
operator priorities and associativities
square root / e-exponential / absolute value
trigonometry
logarithm
euclidean division (both quotient and modulo)
modulo
truncate / round / floor / ceil
bitwise operators
Threads
thread definition
thread creation
thread object creation
starting / stopping threads
passing data directly between threads
terminating thread communication due to a time-out
Thread Synchronization
Joining Another Thread
Thread Prioritization
Thread-safe sharing of data without synchronization



Access modifiers
Advice
Anaphoric macro
Append
Array slicing
Assembly
Autoload
Barton-Nackman trick
Brace notation
Business object
Class
Collective operation
Comparison of programming languages
Concurrent ML
Constant
Critical section
Delimiter
Docblock
Docstring
Fat comma
Fexpr
First-class citizen
Forward declaration
Generator
Hazard pointer
Here document
Include directive
Index notation
Indirection
Initialization
Interface (computing))
Keyword
Language construct
List comprehension
Literal
Load-link/store-conditional
Macro (computer science))
Metatable
Monitor (synchronization))
Monkey patch
Naming collision
Occurs check
Operator
Overlapped I/O
Parameterized macro
Path expression
Persistent object store
Phantom reference
Postcondition
Precondition
Predeclared
Program structure tree
Pyramid of doom
Range
Reflection
Regular expression
Reserved word
Resource management (computing))
Spinlock
Block
String interpolation
Strong key
Subroutine
Symbol
Symbolic language
Tagged pointer
Tombstone
Type punning
TypeParameter
XML data binding
# PLT

* PL Implementation
  - Compiled
    - AOT
  - Interpreted
    - JIT
    - Hot
* Concepts
* Aspects
* Typing
* First-class citizenship
- Typing discipline
- Paradigms: Imperative, Functional, OO, Logic
- Concepts:
  - generics
  - closures
  - classes
  - objects
  - interfaces
  - traits
  - objects
  - first class functions
  - iterators
  - generators
  - async
  - concurrency
  - reflection
  - FFI
  - pointers
- Objects
- Inheritance
- Functions
- Lazy Evaluation
- Variable Scope
- Multithreading
- concurrency
- Dynamic Programming
- statement
- expression
- macro
- attributes
- unsafe
- pattern matching
* Types
  - tuples
  - algebraic sum types: option type, result type, tagged enum
  - algebraic pi (dependent) types
  - null?
  - struct
  - enum
  - Union
  - array
  - collection
- Errors, Exceptions
- Keywords
- Control flow
- variable ownership
- variable mutability
- std
- packages/modules
- package manager

* Type theory
  - Type system
  - Types
  - Type inference
* Compiler theory
  - Compile-time
  - Compiler types
  - Compiler technics
  * Compiler phases
    - Syntax Analysis
      - Scanning
      - Parsing
    - Semantic Analysis
    - Optimization
    - Code Generation
* Formal semantics
  - Denotational Semantics
  - Operational Semantics
  - Axiomatic Semantics
* Program Analysis
  - Program Analysis
  - Program Transformation
  - Comparative PL Analysis
    - Programming Paradigms classification
  - Metaprogramming
  - Domain-specific Language
* Runtime
  - Runtime Environment
  - Virtual Machine
  - Garbage Collection
  - Foreign Function Interface





* PL Constructs
  - values: literals, constants, scalar, compound, objects, refs
  - variables: bound, free, params, args,
  - procedure: subroutine, function, closure, lambda, anonymous, callable
  - class
  - object

Expressions Functions Heap storage Exceptions Modules Objects Threads

* PL Concepts
  - datatype
  - binding
  - scope
  - state
  - IO

* PL Phases (time)
  - authoring-time, design-time,
  - compile-time
  - run-time
  - debugging-time
  - testing-time


* by forks in the road
  - type system
  - safety
  - provable
  - threads (sys vs green)


* by dev methodology (not here, put in software)
  - extreme
  - waterfall


## PL Classification

* by evaluation strategy
  - normal, applicative
  - lazy, call-by-need
* by type system
  - static, dynamic
  - weak, strong
* by paradigms
  - imperative
  - declarative
  - functional
* by abstraction
  - machine code
  - object code
  - byte code
  - intermediate lang
  - assembly
* by implementation
  - interpreted, JIT
  - compiled
  - mixed
* by generation
  - first gen
  - second gen
  - third gen
  - fourth gen
  - fifth gen
* by level
  - low-level
  - mid-level
  - high-level
* by style
  - C style, *"braces n' semi-colons"*
    - B, C, C++, C#, D, Nim, Java
  - Python style, *layout and whitespace*
    - py, Haskell
* by purpose
  - system programming
    - C, C++, Rust
  - embedded
    - bash, blackbox
  - teaching
    - Lego ?, Racket
  - Shell
    - bash, powershell
  - DSL
    - docker, ansiable
  - scripting
    - ruby, py, js
  - Math
    - Matematica, WA, MathML
  - Publishing
    - GhostScript
    - MathML
    - latex, tex, katex
  - markup
      - HTML, XHTML
      - Markdown, ASCII
      - MathML
  - configuration
    - XML
    - JSON, jsonc
    - TOML
    - ini
    - yaml

* by expressiveness
* by popularity
* by age
* by feature *for popularizing a thing*


Action
Agent-oriented
Array-oriented
Automata-based
Concurrent computing
Relativistic programming
Data-driven
Declarative
Imperative
Functional
Functional logic
Purely functional
Logic
Abductive logic
Answer set
Concurrent logic
Functional logic
Inductive logic
Constraint
Constraint logic
Concurrent constraint logic
Dataflow
Flow-based
Reactive
Ontology
Differentiable
Dynamic/scripting
Event-driven
Function-level
Value-level
Point-free style
Concatenative
Generic
Imperative
Declarative
Procedural
Object-oriented
Polymorphic
Intentional
Language-oriented
Domain-specific
Literate
Natural-language programming
Metaprogramming
Automatic
Inductive programming
Reflective
Attribute-oriented
Macro
Template
Non-structured
Structured
Array
Nondeterministic
Parallel computing
Process-oriented
Probabilistic
Quantum
Stack-based
Structured
Non-structured
Block-structured
Object-oriented
Actor-based
Class-based
Concurrent
Prototype-based
separation of concerns
Aspect-oriented
Role-oriented
Subject-oriented
Recursive
Symbolic
Value-level
Function-level

side effects

# PL › TOPICS



- Popular paradigms
  - Imperative, OOP
  - Functional, Declarative
  - Mixed paradigm
  - Logic
- ALL Paradigms
  - Action
  - Agent-oriented
  - Array-oriented
  - Automata-based
  - Concurrent computing
  - Relativistic programming
  - Data-driven
  - Declarative (contrast: Imperative)
  - Functional
  - Functional logic
  - Purely functional
  - Logic
  - Abductive logic
  - Answer set
  - Concurrent logic
  - Functional logic
  - Inductive logic
  - Constraint
  - Constraint logic
  - Concurrent constraint logic
  - Dataflow
  - Flow-based
  - Reactive
  - Ontology
  - Differentiable
  - Dynamic/scripting
  - Event-driven
  - Function-level (contrast: Value-level)
  - Point-free style
  - Concatenative
  - Generic
  - Imperative (contrast: Declarative)
  - Procedural
  - Object-oriented
  - Polymorphic
  - Intentional
  - Language-oriented
  - Domain-specific
  - Literate
  - Natural-language programming
  - Metaprogramming
  - Automatic
  - Inductive programming
  - Reflective
  - Attribute-oriented
  - Macro
  - Template
  - Non-structured (contrast: Structured)
  - Array
  - Nondeterministic
  - Parallel computing
  - Process-oriented
  - Probabilistic
  - Quantum
  - Stack-based
  - Structured (contrast: Non-structured)
  - Block-structured
  - Object-oriented
  - Actor-based
  - Class-based
  - Concurrent
  - Prototype-based
  - By separation of concerns:
    - Aspect-oriented
    - Role-oriented
    - Subject-oriented
    - Recursive
    - Symbolic
  - Value-level (contrast: Function-level)

- Orientation
  - Attribute-oriented
  - Agent-oriented
- Subject-oriented
- Aspect-oriented
  - Role-oriented

# CS > TPL > Keywords > Basics of PL

Natural language:
- syntax
  - letters
  - syllables
  - roots, prefix, suffix, infix
  - words
  - sentences
  - phrases
  - paragraphs, thoughts
- functionality
  - subject
  - predicate
  - object
- Nominal
  - noun
  - adjective
  - verb
  - adverb
  - proposition
  - article


What are the universal language core elements:
- lang objects
  - values
- means of abstraction
  - variables
  - references
  - procedures
  - functions
- sentences: expressions
control flow
- type system
- language specification





* syntax
  - reserved words
  - keywords
  - control-flow constructs
  - user-defined identifiers


expression
statement
declaration
definition
initialization
variable
constant
binding
name
identifier
scope
lexical scope
dynamic scope

* type system

semantics


* lambda calculus
  - specification
    - syntax
    - syntactical entities
      - keywords: `λ`, `.`, `(`, `)`
    - semantics
      - encoding values as functions
      - interpretation of functions
      - encoding systems
        - Church encoding
          - Church numbers
        - Scott encoding
  - lambda expression
  - lambda terms
    * variables (ranging over lambda terms)
      - free vars
      - bound vars
    * function abstraction
      - combinators
      - lambda binder, header
    * function application
      - substitution
        - capture-free substitution
      - equivalence
        - alpha equivalence
      - beta-reduction
      - redex
      - evaluation order
        - applicative order
        - normal order
        - strict evaluation
        - non-strict evaluation
        - WHNF
        - normal form
        - Church-Rosser theorem
      - eta-reduction
      - eta-expansion
  - computability
    - Church-Turing theorem

# PL HIERARCHY

https://en.wikipedia.org/wiki/Category:Programming_language_classification


Topics
- Classifications, types, factors, paradigms,
- Type systems
- Concepts and constructs
- Means of abstraction
- Components
- Expressiveness (vs Provability)


Pl abstractions:
- procedure, routine, function
- macros
- class
- module
- package
- component
- microservices

PL concepts:
- type system
- generics
- iterators
- concurrency
- async: async/wait, futures, promises, generators
- error handling: ADT, exceptions, (in-band) signaling, NULL, nullability

PL components (generalizations):
- control flow
- code org
- types
- data structures


# TPL

* Comments
  - line comment
  - end-of-line comment
  - block comment
  - nested comment
  - comment disabling code
  - doc comment
  - doc comment scope (related to the immediately following lang item: module, function, class, etc.)
  - docblocks comment (IDE hints, generate usage)
  - docblocks comment: live code, markdown syntax


* Scope
  - static
  - dynamic
  statements
  expressions
    Conditional expressions
  scope
    block scope
    fn scope
    lexical scope
    dynamic scope
  labels
  braces
  block


* Invokable
  procedure
  routine
  subprocedure
  functional instruction
  closure
  macro
  function
  function call
  method
  generator
  anonymous function
  lambda function
  function type
  operator
  functional
  higher-order function
  iterator
  generator function
  async function
  reflection (calling and declaring functions by strings)


Literals
  numbers
  bool
  strings
    String operations
    String functions
    herestring
    heredoc
    string templates
  compound types
    arrays
    maps
    objects
    structs

Memory
  stack
  heap
  boxing
  manual memory allocation
  force garbage collection
  statics
  binding time

Control flow
  Foreach loops
  While loops
  For loops
  Do-while

Error handling
  null
  exceptions
  try/catch
  in-band signalling

Types
  buildin types
  compound types
  user types
  algebraic types
  structs
  Enumerated types
  Type systems
  Arrays
  Associative arrays
  List comprehension
  Object-oriented programming 
  Object-oriented constructors
  Algebraic data types
    dependent types
    Record
    Tuple
    Union


Declarations and binding (variables)
  ownership
  lifetime
  Assignment
    assignment as exprssion
    multi assignment
  declaration
  mutability
  init
  definition
  hoisting
  destructuring
  privacy/visibility
    private
    public
    protected
    internal
    sealed


Evaluation strategy
  normal
  strict
  lazy
  binding
    early binding
    late binding
    static binding

Concurrency
  safety
  threads
  channels


generics
  generic types
polymorphism
inheritance
composition
futures/promises
modules
